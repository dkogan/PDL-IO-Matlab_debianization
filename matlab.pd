##-*- Mode: Perl -*-
use strict;
use warnings;

our $VERSION = '0.001';
pp_setversion("'$VERSION'");

my $Matio_src = 'matio-1.5.0/src';

my ($MAT_FT_MAT73,$MAT_FT_MAT5,$MAT_FT_MAT4) = (0,1,2);

my %Enums;

sub make_enum_hash {
    open my $fh, '<', "$Matio_src/matio.h" or die "Can't open matio.h";
    my $in_enum = 0;
    my $enum_name;
    while(<$fh>) {
        if ($in_enum) {
            if ( /\}/ ) {
                $in_enum = 0;
                next;
            }
            next unless /^\s+(\w+)\s*=\s*([x\d]+)/;
            my ($name,$val) = ($1,$2);
            $Enums{$enum_name}->{$name} = $val =~/x/ ? hex($val) : $val;
        }
        if ( /^enum\s+(\w+)/ ) {
            $enum_name = $1;
            $in_enum = 1;
            $Enums{$enum_name} = {};
            next;
        }
    }
    close $fh;
}

make_enum_hash();

pp_addpm({At=>'Top'}, <<'EO_TOPMATTER');

=head1 NAME

PDL::IO::Matlab -- Read and write Matlab data files.

=head1 DESCRIPTION

This module provides routines to read and write data files
in Matlab formats.

=head1 SYNOPSIS

 use PDL::LiteF;
 use PDL::IO::Matlab;

=cut

$PDL::onlinedoc->scan(__FILE__) if $PDL::onlinedoc;

use strict;
use warnings;

use PDL::LiteF;
use PDL::NiceSlice;
use PDL::Options;
use Data::Dumper;

EO_TOPMATTER

pp_addpm({At => 'Middle'}, <<'EO_MIDDLE');

my %Format_list =  (
    MAT73 => 0,
    MAT5 => 1,
    MAT4 => 2
    );

my %Inv_format_list =  (
    0 => 'MAT73',
    1 => 'MAT5',
    2 => 'MAT4'
   );

sub new {
    my $class = shift;
    my ($filename,$mode,$iopts) = @_;
    my $opt = new PDL::Options(
        {
            format => undef,
            header => undef
        });
    $iopts ||= {};

    my $opts = $opt->options($iopts);

    my $obj = { 
        filename => undef, 
        format => $opts->{format} || undef,
        mode => undef,
        handle => undef,
        header => $opts->{header} || undef
    };

    $obj->{filename} = $filename if $filename;

    if ( defined $mode ) {
      if ($mode eq 'r' or $mode eq '<') {
        $obj->{mode} = 'r';
      }
      elsif ($mode eq 'w' or $mode eq '>') {
        $obj->{mode} = 'w';
      }
      elsif ($mode eq 'rw' or $mode eq '<>') {
        $obj->{mode} = 'rw';
      }
      else {
        barf "PDL::IO::Matlab::open unknown mode '$mode'";
      }
    }
    elsif (defined $filename) {
      barf("PDL::IO::Matlab::new filename given, but no access mode.");
    }
    barf("PDL::IO::Matlab::new unknown file format")
       if defined $opts->{format} and not exists $Format_list{$opts->{format}};
    bless $obj, $class;
    $obj->open() if defined $filename;
    $obj;
}

# may want to keep track of state at some point,
# an automatically close.
sub DESTROY {
    my $self = shift;
#    $self->close;
}

sub open {
    my $self = shift;
    my $mode = $self->get_mode();
    my $filename = $self->get_filename();
    my $handle;
    if ( $mode eq 'r' ) {
        $handle = _mat_open_read($filename);
    }
    elsif ( $mode eq 'w' ) {
        $self->get_format || $self->set_format('MAT73');
        my $header = $self->get_header();
        my $header_flag = defined $header ?  1 : 0;
        $header = '' unless defined $header;
        $handle = _mat_create_ver(
            $filename, $header, $Format_list{$self->get_format}, $header_flag);
    }
    elsif ( $mode eq 'rw' ) {
        $handle = _mat_open_read_write($filename);
    }
    else {
        barf "PDL::IO::Matlab::open unknown mode '$mode'";
    }
    barf "PDL::IO::Matlab::open Can't open '$filename' in mode $mode" unless $handle;
    $self->set_handle($handle);
    $self->get_format || $self->set_format($self->get_version);
    $self;
}

sub close {
    my $self = shift;
   _mat_close($self->get_handle() );
   $self;
}

sub get_handle {
    my $self = shift;
    barf 'PDL::IO::Matlab::get_handle handle not defined.' unless
          defined $self->{handle};
    $self->{handle};
}

sub set_handle {
    my $self = shift; 
    $self->{handle} = shift;
}

sub get_mode {
    my $self = shift;
    barf 'PDL::IO::Matlab::get_mode mode not defined.' unless
          defined $self->{mode};
    $self->{mode};
}

sub set_mode {
    my $self = shift; 
    $self->{mode} = shift;
}

sub get_filename {
    my $self = shift;
    barf 'PDL::IO::Matlab::get_filename filename not defined.' unless
          defined $self->{filename};
    $self->{filename};
}

sub get_format {
    my $self = shift;
#    barf 'PDL::IO::Matlab::get_format format not defined.' unless
#          defined $self->{format};
    $self->{format};
}

sub set_format {
    my $self = shift; 
    $self->{format} = shift;
}

sub get_header {
    my $self = shift;
    $self->{header};
}

sub set_header {
    my $self = shift; 
    $self->{header} = shift;
}

sub get_version {
    my $self = shift;
    my $val = _mat_get_version($self->get_handle);
#    print "val = $val\n";
    $Inv_format_list{$val};
}

sub print_all_var_info {
    my $self = shift;
    my %user_options = @_;
    my %opts = parse( {print_data => 0} , \%user_options);
    my $printdata = $opts{print_data} ? 1 : 0;
    my $handle = $self->get_handle;
    _extra_matio_print_all_var_info($handle,$printdata);
}

sub read_next {
    my $self = shift;
    _convert_next_matvar_to_pdl($self->get_handle);
}

sub write_pdls {
   my $self = shift;
   my @pdls = @_;
   foreach (@pdls) {
       _write_pdl_to_matlab_file($self->get_handle,$_);
   }
}


# broken
#sub print_all_var_info_new {
#    my $self = shift;
#    my $handle = $self->get_handle;
#    _extra_matio_print_all_var_info($handle,1,10,10);
#}

EO_MIDDLE

pp_addhdr( qq{
#include <stdio.h>
#include <stdlib.h>
#include "$Matio_src/matio.h"
//#include "$Matio_src/matio_private.h"
//#include "$Matio_src/mat5.h"
//#include "$Matio_src/mat4.h"
//#include "$Matio_src/mat73.h"
//#include "mat_var_print.c"
#include "extra_matio.c"
#include "convert_matvar_pdl.c"
});

pp_add_exported qw();

# The line MODULE = ... is also added by PP, so this
# is redundant

pp_addxs ( '', '

MODULE = PDL::IO::Matlab PACKAGE = PDL::IO::Matlab

mat_t *
_mat_open_read( filename )
 char * filename
 CODE:
 RETVAL = Mat_Open(filename,MAT_ACC_RDONLY);
 OUTPUT:
 RETVAL

mat_t *
_mat_open_read_write( filename )
 char * filename
 CODE:
 RETVAL = Mat_Open(filename,MAT_ACC_RDWR);
 OUTPUT:
 RETVAL

int
_mat_close( handle )
  mat_t * handle
  CODE:
  /* always returns 0 */
  RETVAL = Mat_Close(handle);
  OUTPUT:
  RETVAL

');


pp_addxs ( '', "

mat_t *
_mat_create_ver( matname, hdr_str, mat_file_ver_in, header_flag)
 char * matname
 char * hdr_str
 int  mat_file_ver_in
 int  header_flag
 CODE:
 enum mat_ft mat_file_ver;
 switch (mat_file_ver_in)
    {
     case $MAT_FT_MAT73:
              {
                mat_file_ver = MAT_FT_MAT73;
                break;
              }
     case $MAT_FT_MAT5:
              {
                mat_file_ver = MAT_FT_MAT5;
                break;
              }
     case $MAT_FT_MAT4:
              {
               barf(\"PDL::IO::Matlab::open Writing in format version MAT4 not supported.\");
              }
     default:
          barf(\"PDL::IO::Matlab::open unknown file format.\");
    }
 if (header_flag)
     RETVAL = Mat_CreateVer(matname, hdr_str, mat_file_ver);
 else RETVAL = Mat_CreateVer(matname, (void *) NULL, mat_file_ver);
 OUTPUT:
 RETVAL

");

pp_addxs ( '',  "

int
_mat_get_version(matfp)
 mat_t * matfp
 CODE:
 enum mat_ft mat_file_ver;
 int retval;
 mat_file_ver = Mat_GetVersion(matfp);
 /* fprintf(stderr, \"in C vers %d\", mat_file_ver); */
 switch (mat_file_ver)
    {
     case MAT_FT_MAT73:
              {
                retval= $MAT_FT_MAT73;
                break;
              }
     case MAT_FT_MAT5:
              {
                retval= $MAT_FT_MAT5;
                break;
              }
     case MAT_FT_MAT4:
              {
                retval= $MAT_FT_MAT4;
                break;
              }
     default:
          {
        barf(\"PDL::IO::Matlab::get_version returned unknown version.\");
         }
     }
  RETVAL = retval;
  OUTPUT:
  RETVAL
");

pp_addxs( '', '

void
_read_data (mat, matvar)
mat_t * mat
matvar_t * matvar
CODE:
ReadData(mat,matvar);

void
_mat_print_number(type, data)
int type
void * data
CODE:
Mat_PrintNumber( (enum matio_types) type, data);

void
get_library_version()
  INIT:
  int major,minor,release;

  PPCODE:
  Mat_GetLibraryVersion(&major, &minor, &release);
  XPUSHs(sv_2mortal(newSVnv(major)));
  XPUSHs(sv_2mortal(newSVnv(minor)));
  XPUSHs(sv_2mortal(newSVnv(release)));

int
_mat_rewind(mat)
mat_t * mat
CODE:
int retval;
retval = Mat_rewind(mat);
if (retval == -1) barf("PDL::IO::Matlab::rewind Bad filehandle");
RETVAL = retval;
OUTPUT:
RETVAL



');



pp_addxs ( '',  '

=pod

void
_extra_matio_print_all_var_info_new (matfp,printdata,max_cols,max_rows)
mat_t * matfp
int printdata
int max_cols
int max_rows
CODE:
extra_matio_print_all_var_info (matfp,printdata,max_cols,max_rows);

=cut

void
_extra_matio_print_all_var_info (matfp,printdata)
mat_t * matfp
int printdata
CODE:
extra_matio_print_all_var_info(matfp,printdata);

pdl *
_convert_next_matvar_to_pdl(matfp)
mat_t * matfp
CODE:
RETVAL = convert_next_matvar_to_pdl(matfp);
OUTPUT:
RETVAL

int
_write_pdl_to_matlab_file (mat, piddle)
mat_t * mat
pdl * piddle
CODE:
RETVAL = write_pdl_to_matlab_file (mat, piddle);
OUTPUT:
RETVAL

');

pp_done();


1;
