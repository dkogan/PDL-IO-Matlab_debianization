##-*- Mode: Perl -*-
use strict;
use warnings;

our $VERSION = '0.001';
pp_setversion("'$VERSION'");

my $Matio_src = 'matio-1.5.0/src';

# This works nicely, but I am not using it for anything
my ($MAT_FT_MAT73,$MAT_FT_MAT5,$MAT_FT_MAT4) = (0,1,2);
my %Enums;
sub make_enum_hash {
    open my $fh, '<', "$Matio_src/matio.h" or die "Can't open matio.h";
    my $in_enum = 0;
    my $enum_name;
    while(<$fh>) {
        if ($in_enum) {
            if ( /\}/ ) {
                $in_enum = 0;
                next;
            }
            next unless /^\s+(\w+)\s*=\s*([x\d]+)/;
            my ($name,$val) = ($1,$2);
            $Enums{$enum_name}->{$name} = $val =~/x/ ? hex($val) : $val;
        }
        if ( /^enum\s+(\w+)/ ) {
            $enum_name = $1;
            $in_enum = 1;
            $Enums{$enum_name} = {};
            next;
        }
    }
    close $fh;
}

make_enum_hash();

pp_addpm({At=>'Top'}, <<'EO_TOPMATTER');

=head1 NAME

PDL::IO::Matlab -- Read and write Matlab format data files.

=head1 DESCRIPTION

This module provides routines to read and write pdls to and from
data files in Matlab formats. The module uses the matio C library.
Both functional and OO interface are provided.

Only real, multi-dimensional arrays correpsonding to PDL data types are supported.
Compression is not yet supported.

=head1 SYNOPSIS

 use PDL;
 use PDL::IO::Matlab qw( read_matlab write_matlab );

 # write two pdls in matlab 5 format
 write_matlab('file.dat', $x, $y);

 # read an array of piddles 
 # from file in matlab 4, 5, or 7.3 format.
 my @pdls =  read_matlab('file.dat');
 
 # write pdl in matlab 7.3 format.
 write_matlab('file.dat', 'MAT73', $x);

=cut

$PDL::onlinedoc->scan(__FILE__) if $PDL::onlinedoc;

use strict;
use warnings;

use PDL::LiteF;
use PDL::NiceSlice;
use PDL::Options;
use Data::Dumper;

EO_TOPMATTER

pp_addpm({At => 'Middle'}, <<'EO_MIDDLE');

my %Format_list =  (
    MAT73 => 0,
    MAT5 => 1,
    MAT4 => 2
    );

my %Inv_format_list =  (
    0 => 'MAT73',
    1 => 'MAT5',
    2 => 'MAT4'
   );

# non-OO functions

=head1 FUNCTIONS

The functional interface.

=head2 B<read_matlab>

=head3 Usage

C<@pdls = read_matlab($filename);>

Reads all data in the file C<$filename>.
Formats 4, 5, and 7.3 are supported.

=cut

sub read_matlab {
    my ($filename) = @_;
    my $mat = PDL::IO::Matlab->new($filename, '<');
    my @res = $mat->read_all;
    $mat->close;
    @res;
}


=head2 B<write_matlab>

=head3 Usage

 write_matlab($filename,$x1,$x2,...);
 write_matlab($filename,$format,$x1,$x2,...);

Write pdls C<$x1>, C<$x2>,.... If present, C<$format>
must be either C<'MAT5'> or C<'MAT73'>.

Currently there is a bug that only allows a single pdl
to be written in the format C<'MAT73'>.

=cut

sub write_matlab {
    my @strings;
    my @refs;
    while(@_) {
        my $v = shift;
        if ( ref($v) ) {
            push @refs, $v;
        }
        else {
            push @strings, $v;
        }
    }
    barf 'write_matlab: ' . scalar(@strings) . 
        ' string arguments given. One or two expected.'
        if @strings < 1 or @strings > 2 ;
    my $filename = $strings[0];
    my $format = $strings[1] || 'MAT5';
    my $mat = PDL::IO::Matlab->new($filename, '>', { format => $format });
    $mat->write_pdls(@refs) if @refs;
    $mat->close;
    scalar(@refs);
}

=head1 METHODS

=head2 B<new>

=head3 Usage

 # open for writing
 $mat = PDL::IO::Matlab->new('file.dat', '>', {format => 'MAT5'});

 # default format is MAT5
 $mat = PDL::IO::Matlab->new('file.dat', '>');

 # may use 'w' or '>'
 $mat = PDL::IO::Matlab->new('file.dat', 'w');

 # supply header
 $mat = PDL::IO::Matlab->new('file.dat', '>', { header => 'some text'} );

 # read-write  with rw or <>
 $mat = PDL::IO::Matlab->new('file.dat', 'rw');  

=cut

sub new {
    my $class = shift;
    my ($filename,$mode,$iopts) = @_;
    my $opt = new PDL::Options(
        {
            format => undef,
            header => undef
        });
    $iopts ||= {};

    my $opts = $opt->options($iopts);

    my $obj = { 
        filename => undef, 
        format => $opts->{format} || undef,
        mode => undef,
        handle => undef,
        header => $opts->{header} || undef
    };

    $obj->{filename} = $filename if $filename;

    if ( defined $mode ) {
      if ($mode eq 'r' or $mode eq '<') {
        $obj->{mode} = 'r';
      }
      elsif ($mode eq 'w' or $mode eq '>') {
        $obj->{mode} = 'w';
      }
      elsif ($mode eq 'rw' or $mode eq '<>') {
        $obj->{mode} = 'rw';
      }
      else {
        barf "PDL::IO::Matlab::open unknown mode '$mode'";
      }
    }
    elsif (defined $filename) {
      barf("PDL::IO::Matlab::new filename given, but no access mode.");
    }
    barf("PDL::IO::Matlab::new unknown file format")
       if defined $opts->{format} and not exists $Format_list{$opts->{format}};
    bless $obj, $class;
    $obj->open() if defined $filename;
    $obj;
}

# may want to keep track of state at some point,
# an automatically close.
sub DESTROY {
    my $self = shift;
#    $self->close;
}

sub open {
    my $self = shift;
    my $mode = $self->get_mode();
    my $filename = $self->get_filename();
    my $handle;
    if ( $mode eq 'r' ) {
        $handle = _mat_open_read($filename);
    }
    elsif ( $mode eq 'w' ) {
        $self->get_format || $self->set_format('MAT5');
        my $header = $self->get_header();
        my $header_flag = defined $header ?  1 : 0;
        $header = '' unless defined $header;
        $handle = _mat_create_ver(
            $filename, $header, $Format_list{$self->get_format}, $header_flag);
    }
    elsif ( $mode eq 'rw' ) {
        $handle = _mat_open_read_write($filename);
    }
    else {
        barf "PDL::IO::Matlab::open unknown mode '$mode'";
    }
    barf "PDL::IO::Matlab::open Can't open '$filename' in mode $mode" unless $handle;
    $self->set_handle($handle);
    $self->get_format || $self->set_format($self->get_version);
    $self;
}

=head2 B<close>

=head3 Usage

$mat->close;

Close matlab file and free memory associated with C<$mat>.

=cut

sub close {
    my $self = shift;
   _mat_close($self->get_handle() );
   $self;
}

=head2 B<read_next>

=head3 Usage

 my $x = $mat->read_next;
 print "End of file\n" unless ref($x);

 my ($err,$x) = $mat->read_next;
 print "End of file\n" if $err;

Read one pdl from file associated with object C<$mat>.

=cut

sub read_next {
    my $self = shift;
    my $pdl = _convert_next_matvar_to_pdl($self->get_handle);
    my $err = ref($pdl) ? 0 : 1;
    return ($err,$pdl);
}

=head2 B<read_all>

=head3 Usage

 my @pdls = $mat->read_all;

Read all remaining pdls from file associated with object C<$mat>.

=cut

sub read_all {
    my $self = shift;
    my @res;
    while(1) {
        my ($err,$pdl) = read_next($self);
        last if $err;
        push @res, $pdl;
    }
    @res;
}

=head2 B<write_pdls>

=head3 Usage

 $mat->write_pdls($x1,$x2,...);

Append pdls to open file associated with C<$mat>.
NOTE!! There is a bug that prevents writing more
than one pdl to a file in format 7.3.

=cut

sub write_pdls {
   my $self = shift;
   my @pdls = @_;
   foreach (@pdls) {
       _write_pdl_to_matlab_file($self->get_handle,$_);
   }
   return $self;
}

=head2 B<rewind>

=head3 Usage

 $mat->rewind

Reset pointer to the head of the file.

=cut

sub rewind {
    my $self = shift;
    _mat_rewind($self->get_handle);
}


sub get_handle {
    my $self = shift;
    barf 'PDL::IO::Matlab::get_handle handle not defined.' unless
          defined $self->{handle};
    $self->{handle};
}

sub set_handle {
    my $self = shift; 
    $self->{handle} = shift;
}

sub get_mode {
    my $self = shift;
    barf 'PDL::IO::Matlab::get_mode mode not defined.' unless
          defined $self->{mode};
    $self->{mode};
}

sub set_mode {
    my $self = shift; 
    $self->{mode} = shift;
}

=head2 B<get_filename>

=head3 Usage

 $mat->get_filename

Return name of file associated with C<$mat>.

=cut

sub get_filename {
    my $self = shift;
    barf 'PDL::IO::Matlab::get_filename filename not defined.' unless
          defined $self->{filename};
    $self->{filename};
}

=head2 B<get_format>

=head3 Usage

 $mat->get_format

Return matlab data file format for file associated with
C<$mat>. One of C<'MAT4'>, C<'MAT5'>, or C<'MAT73'>.

=cut

sub get_format {
    my $self = shift;
#    barf 'PDL::IO::Matlab::get_format format not defined.' unless
#          defined $self->{format};
    $self->{format};
}

sub set_format {
    my $self = shift; 
    $self->{format} = shift;
}

sub get_header {
    my $self = shift;
    $self->{header};
}

sub set_header {
    my $self = shift; 
    $self->{header} = shift;
}

sub get_version {
    my $self = shift;
    my $val = _mat_get_version($self->get_handle);
#    print "val = $val\n";
    $Inv_format_list{$val};
}

=head2 B<print_all_var_info>

=head3 Usage

 $mat->print_all_var_info;

 # also print a small amount of data from each variable.
 $mat->print_all_var_info( {print_data => 1} );

Print a summary of all data in the file associated
with C<$mat> (starting from the next unread variable.)

=cut

sub print_all_var_info {
    my $self = shift;
    my %user_options = @_;
    my %opts = parse( {print_data => 0} , \%user_options);
    my $printdata = $opts{print_data} ? 1 : 0;
    my $handle = $self->get_handle;
    _extra_matio_print_all_var_info($handle,$printdata);
}


=head1 AUTHOR

John Lapeyre, C<< <jlapeyre at cpan.org> >>

=head1 LICENSE AND COPYRIGHT

Copyright 2012 John Lapeyre.

This program is free software; you can redistribute it and/or modify it
under the terms of either: the GNU General Public License as published
by the Free Software Foundation; or the Artistic License.

See http://dev.perl.org/licenses/ for more information.

The matio library included here is 
Copyright 2011 Christopher C. Hulbert. All rights reserved.
See the file matio-1.5/COPYING in the source distribution
of this module.

=cut

# broken
#sub print_all_var_info_new {
#    my $self = shift;
#    my $handle = $self->get_handle;
#    _extra_matio_print_all_var_info($handle,1,10,10);
#}

###########################################################################
EO_MIDDLE

pp_addhdr( qq{
#include <stdio.h>
#include <stdlib.h>
#include "$Matio_src/matio.h"
//#include "$Matio_src/matio_private.h"
//#include "$Matio_src/mat5.h"
//#include "$Matio_src/mat4.h"
//#include "$Matio_src/mat73.h"
//#include "mat_var_print.c"
#include "extra_matio.c"
#include "convert_matvar_pdl.c"
});

pp_add_exported qw( read_matlab write_matlab );

# The line MODULE = ... is also added by PP, so this
# is redundant

pp_addxs ( '', '

MODULE = PDL::IO::Matlab PACKAGE = PDL::IO::Matlab

mat_t *
_mat_open_read( filename )
 char * filename
 CODE:
 RETVAL = Mat_Open(filename,MAT_ACC_RDONLY);
 OUTPUT:
 RETVAL

mat_t *
_mat_open_read_write( filename )
 char * filename
 CODE:
 RETVAL = Mat_Open(filename,MAT_ACC_RDWR);
 OUTPUT:
 RETVAL

int
_mat_close( handle )
  mat_t * handle
  CODE:
  /* always returns 0 */
  RETVAL = Mat_Close(handle);
  OUTPUT:
  RETVAL

');


pp_addxs ( '', "

mat_t *
_mat_create_ver( matname, hdr_str, mat_file_ver_in, header_flag)
 char * matname
 char * hdr_str
 int  mat_file_ver_in
 int  header_flag
 CODE:
 /* following should be written w/o conditionals ! */
 enum mat_ft mat_file_ver;
 switch (mat_file_ver_in)
    {
     case $MAT_FT_MAT73:
              {
                mat_file_ver = MAT_FT_MAT73;
                break;
              }
     case $MAT_FT_MAT5:
              {
                mat_file_ver = MAT_FT_MAT5;
                break;
              }
     case $MAT_FT_MAT4:
              {
               barf(\"PDL::IO::Matlab::open Writing in format version MAT4 not supported.\");
              }
     default:
          barf(\"PDL::IO::Matlab::open unknown file format.\");
    }
 if (header_flag)
     RETVAL = Mat_CreateVer(matname, hdr_str, mat_file_ver);
 else RETVAL = Mat_CreateVer(matname, (void *) NULL, mat_file_ver);
 OUTPUT:
 RETVAL

");

pp_addxs ( '',  "

int
_mat_get_version(matfp)
 mat_t * matfp
 CODE:
 enum mat_ft mat_file_ver;
 int retval;
 mat_file_ver = Mat_GetVersion(matfp);
 /* fprintf(stderr, \"in C vers %d\", mat_file_ver); */
 /* This could be done much more easily ! */
 switch (mat_file_ver)
    {
     case MAT_FT_MAT73:
              {
                retval= $MAT_FT_MAT73;
                break;
              }
     case MAT_FT_MAT5:
              {
                retval= $MAT_FT_MAT5;
                break;
              }
     case MAT_FT_MAT4:
              {
                retval= $MAT_FT_MAT4;
                break;
              }
     default:
          {
        barf(\"PDL::IO::Matlab::get_version returned unknown version.\");
         }
     }
  RETVAL = retval;
  OUTPUT:
  RETVAL
");

pp_addxs( '', '

void
_read_data_all (mat, matvar)
mat_t * mat
matvar_t * matvar
CODE:
Mat_VarReadDataAll(mat,matvar);

void
get_library_version()
  INIT:
  int major,minor,release;

  PPCODE:
  Mat_GetLibraryVersion(&major, &minor, &release);
  XPUSHs(sv_2mortal(newSVnv(major)));
  XPUSHs(sv_2mortal(newSVnv(minor)));
  XPUSHs(sv_2mortal(newSVnv(release)));

int
_mat_rewind(mat)
mat_t * mat
CODE:
RETVAL = Mat_Rewind(mat);
if (RETVAL == -1) barf("PDL::IO::Matlab::rewind Bad filehandle");
OUTPUT:
RETVAL

=pod

int
_my_mat_feof(mat)
mat_t * mat
CODE:
RETVAL = feof(mat->fp);
OUTPUT:
RETVAL

=cut


');



pp_addxs ( '',  '

=pod

void
_extra_matio_print_all_var_info_new (matfp,printdata,max_cols,max_rows)
mat_t * matfp
int printdata
int max_cols
int max_rows
CODE:
extra_matio_print_all_var_info (matfp,printdata,max_cols,max_rows);

=cut

void
_extra_matio_print_all_var_info (matfp,printdata)
mat_t * matfp
int printdata
CODE:
extra_matio_print_all_var_info(matfp,printdata);

=pod

following was a PITA. This returns undef if the
reading matvar failed. The library does not seem
to provide any way to detect EOF.

=cut

pdl *
_convert_next_matvar_to_pdl(matfp)
mat_t * matfp
CODE:
pdl * retval;
retval = convert_next_matvar_to_pdl(matfp);
ST(0) = sv_newmortal(); 
if (retval != NULL) PDL->SetSV_PDL(ST(0),retval);


int
_write_pdl_to_matlab_file (mat, piddle)
mat_t * mat
pdl * piddle
CODE:
RETVAL = write_pdl_to_matlab_file (mat, piddle);
OUTPUT:
RETVAL


');

pp_done();


1;
